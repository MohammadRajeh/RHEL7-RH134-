
Exercise Description
In this exercise, we are going to automatically generate an SELinux policy framework, and learn to handle AVC messages that are generated by SELinux, when the application violates the policy.

Step 1: Generate an initial generic SELinux policy
Create a policy directory, and generate an initial policy. Use sepolicy generate to generate a policy for the app that we want to enable.

  # cd ~/src
  # mkdir policy
  # cd policy
  # sepolicy generate --init /usr/local/sbin/testapp

    Note the last few lines in the output from sepolicy generate:

    Created the following files:
    /home/ec2-user/src/policy/testapp.te # Type Enforcement file
    /home/ec2-user/src/policy/testapp.if # Interface file
    /home/ec2-user/src/policy/testapp.fc # File Contexts file
    /home/ec2-user/src/policy/testapp_selinux.spec # Spec file
    /home/ec2-user/src/policy/testapp.sh # Setup Script

    You will need all of these files to customize the policy, for the application.

    SELinux Policy Source Compnents
    - testapp.te is the base policy for the application. It sets the rules for the testapp_t domain

    - testapp.if is the interface file. Interfaces are like public functions, in that they provide ways for other SELinux modules to interact with the one that you are writing

    - testapp.fc is the file contexts file. It contains the labeling information for all filesystem objects that the policy references

    - testapp.sh is a Red Hat provided script that compiles and loads the SELinux policy module

Step 2: Compile the policy framework
   # sudo ./testapp.sh
    The first 9 lines of the output show the policy compilation, the loading of the policy into memory, and the automatic generation of a manpage for the policy:

    Building and Loading Policy
    + make -f /usr/share/selinux/devel/Makefile testapp.pp
    Compiling targeted testapp module
    /usr/bin/checkmodule:  loading policy configuration from tmp/testapp.tmp
    /usr/bin/checkmodule:  policy configuration loaded
    /usr/bin/checkmodule:  writing binary representation (version 19) to tmp/testapp.mod
    Creating targeted testapp.pp policy package
    rm tmp/testapp.mod tmp/testapp.mod.fc
    + /usr/sbin/semodule -i testapp.pp
    + sepolicy manpage -p . -d testapp_t
    ./testapp_selinux.8

Step 3: Check to see your policy in action
    If we reload the application, the newly compiled and loaded policy module will be attached to it:

   # sudo systemctl stop testapp
   # sudo systemctl start testapp
   # ps -efZ | grep testapp | grep -v grep
        system_u:system_r:testapp_t:s0  root      8737     1  0 20:51 ?        00:00:00 /usr/local/sbin/testapp

Step 4: How does the application end up with the testapp_t context?
    This is because of SELinux domain transition rules. The testapp service is started by systemd, which runs with a context of init_t, as it is our init service. Because of the transition rules, it changes contexts when the service is launched. The rule says that any process labeled as init_t will execute any binary labeled as testapp_exec_t, the newly-created process will be labeled as testapp_t.

    To see those rules, type this:

   # sesearch -T -s init_t -t testapp_exec_t
        type_transition init_t testapp_exec_t : process testapp_t;
        The rule says that when any process labeled as init_t executes any binary labeled as testapp_exec_t, the newly-created process will be labeled as testapp_t.

End Result
    At this point, we have a generic policy for the testapp application, which is set for permissive mode. Thus, the application can run, and SELinux will generate alerts when existing system policy is violated, but will take no action.

